`EconomyShop` 플러그인을 단순한 완제품 플러그인이 아니라, **다른 플러그인들이 기반으로 삼을 수 있는 라이브러리(Platform/Framework) 형태**로 확장하려는 계획은 매우 훌륭합니다. 이를 위해서는 내부 로직의 **추상화(Abstraction)**와 **개방성(Extensibility)**을 높이는 방향으로 리팩토링이 필요합니다.

제공해주신 파일 구조를 바탕으로, **EconomyShop API 설계를 위한 구체적인 로드맵과 구조 변경 계획**을 제안합니다.

---

### 1. 코어 구조: API 진입점 (EntryPoint) 구축

다른 플러그인이 `EconomyShop`의 인스턴스를 가져와 기능을 수행할 수 있도록 명확한 API 진입점을 만들어야 합니다.

- **ServiceManager 패턴 도입:**
    
    - Bukkit의 `ServicesManager`를 사용하여 API 인스턴스를 등록하거나, 정적 싱글톤 `EconomyShopAPI.getInstance()`를 제공합니다.
        
    - **계획:**
        
        - `api` 패키지를 신설합니다 (예: `me.antigravity.economyshop.api`).
            
        - `EconomyShopAPI` 인터페이스를 정의하고, 플러그인 내부에서 이를 구현합니다.
            
        - 이 API 인터페이스는 `ShopManager`, `EconomyRegistry`, `ItemRegistry` 등에 접근할 수 있는 getter를 제공합니다.
            

### 수정된 계획: 2. 영구 상점 생성 API (Persistent Shop Registration)

다른 플러그인이 코드로 상점을 정의(`define`)하면, `EconomyShop`이 이를 받아 내부 파일 시스템(`sections.yml` 및 `shops/파일.yml`)에 **자동으로 직렬화(Serialize)하여 저장**하는 구조가 필요합니다.

#### 1. `ShopCreator` (또는 `ShopFactory`) API 도입

단순히 메모리에 객체만 만드는 것이 아니라, **파일 생성까지 담당하는 매니저**가 필요합니다.

- **API 메서드 예시:**
    
    Java
    
    ```
    // 외부 플러그인에서의 호출 예시
    EconomyShopAPI.getInstance().getShopCreator()
        .createSection("rpg_weapon_shop") // 고유 ID
        .displayName("&c무기 상점")
        .icon(Material.IRON_SWORD)
        .slot(12)
        .permission("rpg.shop.weapon")
        .buildAndSave(); // 핵심: 이 시점에 sections.yml에 기록되고 파일이 생성됨
    ```
    

#### 2. `ShopManager`의 저장 로직 확장

현재 `ShopManager`는 `loadShops()`만 있고, 새로운 섹션을 파일에 쓰는 로직은 없습니다. 이를 추가해야 합니다.

- **`registerNewShop(ShopSection section)` 메서드 구현:**
    
    1. **중복 검사:** 이미 같은 ID의 상점이 있는지 확인합니다.
        
    2. **메모리 등록:** `sections` 맵에 즉시 추가하여 리로드 없이 바로 사용 가능하게 합니다.
        
    3. **`sections.yml` 기록:**
        
        - `ConfigManager`를 통해 `sections.yml`에 해당 상점의 메타데이터(아이콘, 이름, 슬롯 등)를 씁니다.
            
    4. **`shops/ID.yml` 파일 생성:**
        
        - 빈 상점 파일(또는 초기 아이템이 포함된 파일)을 물리적으로 생성합니다.
            

#### 3. 외부 플러그인 아이템의 영구 보존 (Item Serialization)

다른 플러그인이 넣은 "고유 아이템(커스텀 NBT 등)"이 서버 리스타트 후에도 유지되려면, **저장 방식(Serialization)**이 중요합니다.

- **문제점:** 일반적인 Bukkit의 `config.set("item", itemStack)`은 복잡한 NBT나 타 플러그인의 커스텀 데이터를 완벽하게 저장하지 못할 때가 많습니다.
    
- **해결책: `ExternalItemSerializer` 도입**
    
    - 다른 플러그인이 아이템을 등록할 때, **"이 아이템을 config에 어떻게 저장하고 복구할지"** 로직을 함께 제공하게 할 수 있습니다.
        
    - 혹은, 가장 안전한 방법으로 **아이템을 Base64 문자열로 변환**하여 YML에 저장하는 옵션을 기본으로 제공합니다. 이렇게 하면 어떤 플러그인의 아이템이든(NBT 포함) 완벽하게 파일로 저장되고 복구됩니다.
        

#### 4. 동적 제어권 (Controller) 유지

상점이 영구적으로 생성된 후에도, 생성한 플러그인이 계속해서 내용을 수정할 수 있어야 합니다.

- **`ShopController` 인터페이스 제공:**
    
    Java
    
    ```
    ShopController controller = EconomyShopAPI.getShop("rpg_weapon_shop");
    
    // 아이템 추가 (즉시 파일에 저장됨)
    controller.addItem(customSword, 1000.0, 500.0); 
    
    // 상점 설정 변경
    controller.updateTitle("&c전설 무기 상점");
    ```
    
    - 이 메서드들은 실행 즉시 `ShopManager`의 `saveShopItem` 등을 내부적으로 호출하여 파일 동기화를 수행합니다.
        

---

### [요약] 수정된 개발 로드맵

1. **API 패키지 신설 (`api.manager.ShopCreator`)**:
    
    - 외부에서 상점 생성 요청을 받아 `ShopSection` 객체를 조립합니다.
        
    - `.buildAndSave()` 호출 시 `ShopManager`로 데이터를 넘깁니다.
        
2. **`ShopManager` 기능 확대**:
    
    - `createSectionFile(ShopSection section)`: `sections.yml`에 설정 추가 및 `shops/id.yml` 파일 생성 로직 구현.
        
    - **Base64 직렬화 지원**: `ItemSerializer` 유틸리티에 `toBase64` / `fromBase64`를 추가하여 복잡한 아이템도 안전하게 YML에 저장하도록 개선.
        
3. **권한 위임 (Ownership)**:
    
    - `ShopSection` 클래스에 `String ownerPlugin` 필드를 추가하여, 어떤 플러그인이 이 상점을 만들었는지 기록해두면 나중에 관리가 편해집니다.
            

### 3. 고유 아이템 (Custom NBT/PDC) 완벽 호환 시스템

다른 플러그인이 정의한 복잡한 아이템(특정 NBT 태그, PersistentDataContainer, CustomModelData 등)을 상점에서 취급하려면, 단순한 `Material` 비교나 `ItemStack.equals`로는 부족합니다.

- **ExternalItemProvider 인터페이스 (API):**
    
    - 다른 플러그인이 아이템을 등록하고, "이 아이템이 상점의 설정과 같은지" 판별하는 로직을 직접 주입할 수 있게 합니다.
        
    - **메서드 예시:**
        
        - `ItemStack getItem(String itemId)`: 아이템 실물 가져오기
            
        - `boolean matches(ItemStack shopItem, ItemStack playerItem)`: **핵심**. 단순 `isSimilar`가 아니라, 해당 플러그인의 기준(예: 특정 UUID 무시, 특정 NBT만 비교)으로 아이템이 같은지 판별하는 권한을 위임합니다.
            
- **ItemMatcher 레지스트리:**
    
    - `ShopItem` 객체 내부에 `matcherType` 필드를 두어, 어떤 플러그인의 로직으로 아이템을 비교할지 지정할 수 있게 합니다.
        

### 4. 경제 시스템의 모듈화 (Custom Economy API)

현재 `EconomyProvider` 인터페이스가 있지만, 이를 더 개방하여 외부에서 새로운 화폐 단위를 등록할 수 있게 합니다.

- **EconomyRegistry 구축:**
    
    - `Vault`, `PlayerPoints` 외에 다른 플러그인이 `EconomyShop`에 자신만의 화폐를 등록하는 시스템입니다.
        
    - **구현 방법:**
        
        - `registerEconomy(String currencyId, EconomyProvider provider)` 메서드 제공.
            
        - 상점 아이템 설정에서 `currency: "MY_CUSTOM_RPG_COIN"` 처럼 문자열 ID로 화폐를 지정하면, 등록된 Provider가 작동하게 변경.
            
    - 이를 통해 RPG 플러그인의 '명예 점수', '토큰' 등을 별도 수정 없이 연동할 수 있습니다.
        

### 5. 상호작용 및 트리거 (Interaction & Trigger)

NPC나 명령어 외에 다른 플러그인의 이벤트(예: 퀘스트 완료 창, 특정 블럭 우클릭)에서 상점을 열 수 있어야 합니다.

- **GUI Open API:**
    
    - `ShopManager`에 `openShop(Player player, String shopId, int page)` 메서드를 public으로 노출합니다.
        
    - 특정 아이템만 필터링해서 보여주는 `openDynamicShop(Player player, List<ShopItem> items)` 기능도 고려해볼 만합니다.
        
- **Pre-Open Event 검증:**
    
    - 상점을 열기 직전에 다른 플러그인이 개입할 수 있도록 로직을 분리합니다.
        

### 6. 이벤트 기반 제어 (Event-Driven Control)

다른 플러그인이 상점의 흐름을 제어("Control")하려면, Bukkit Event 시스템을 적극 활용해야 합니다. 다음 커스텀 이벤트들을 추가/구체화해야 합니다.

- **`ShopPreTransactionEvent` (Cancellable):**
    
    - 구매/판매 **직전**에 호출.
        
    - 다른 플러그인에서 `event.setCancelled(true)`로 거래를 막거나, `event.setPrice(double newPrice)`로 가격을 동적으로 변동시킬 수 있게 합니다 (예: 세금 적용, 할인 이벤트).
        
- **`ShopPostTransactionEvent`:**
    
    - 거래 **성공 후** 호출.
        
    - 로그 기록, 퀘스트 달성 트리거, 업적 시스템 연동에 사용됩니다.
        
- **`ShopOpenEvent` / `ShopCloseEvent`:**
    
    - 상점이 열리고 닫힐 때 호출.
        

---

### [요약] 구체적인 작업 지시서 (Action Plan)

1. **Refactor `EconomyProvider`:**
    
    - `src/main/java/me/antigravity/economyshop/api/economy/EconomyProvider.java`로 이동 및 API 패키지화.
        
    - `EconomyManager`에 `Map<String, EconomyProvider> providers`를 만들고 외부 등록 메서드 작성.
        
2. **Create `ItemMatcher` System:**
    
    - `matches(ItemStack item1, ItemStack item2)` 메서드를 가진 인터페이스 정의.
        
    - 기본값은 바닐라 `isSimilar`. 외부 플러그인은 이를 구현하여 복잡한 NBT 아이템 비교 로직 주입.
        
3. **Expose `ShopAPI` Class:**
    
    - 외부 플러그인은 오직 이 클래스만 import하여 사용하도록 유도.
        
    - Java
        
        ```
          public interface EconomyShopAPI {
              void registerShop(Shop shop);
              void openShop(Player player, String shopId);
              void registerEconomy(String id, EconomyProvider provider);
              ShopBuilder createShopBuilder();
          }
        ```
        
4. **Update `GUIManager`:**
    
    - `Player`와 `ShopID`만 있으면 언제든 GUI를 열 수 있도록 의존성 분리 (현재는 Command나 Listener에 로직이 섞여 있을 수 있음).
        

이러한 구조로 변경하면, 사용자는 님이 만든 플러그인을 단순한 '상점'이 아니라 **'상점 기능을 제공하는 엔진'**으로 사용하여 서버만의 독창적인 시스템을 구축할 수 있게 됩니다.