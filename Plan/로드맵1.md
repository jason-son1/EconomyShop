# EconomyShop 리팩토링 로드맵: 플랫폼화 (Platformization)

이 문서는 EconomyShop 플러그인을 단순 완제품에서 **외부 플러그인이 기반으로 삼을 수 있는 라이브러리 형태**로 전환하기 위한 단계별 계획입니다.

## 📅 Phase 1: API 패키지 분리 및 진입점(Entry Point) 구축

**목표:** 외부 플러그인이 접근해야 할 핵심 인터페이스를 `api` 패키지로 격리하고, 싱글톤 패턴으로 접근 가능한 진입점을 만듭니다.

### 1.1 API 패키지 구조 재편

기존의 내부 구현체와 외부 공개용 인터페이스를 분리합니다.

- **작업:** `src/main/java/me/antigravity/economyshop/api` 패키지 생성
    
- **이동 및 리팩토링:**
    
    - `economy/EconomyProvider.java` -> `api/economy/EconomyProvider.java` (이동)
        
    - `model/ShopItem.java` -> `api/model/ShopItem.java` (인터페이스화 권장, 혹은 DTO로 유지)
        
    - `model/ShopSection.java` -> `api/model/ShopSection.java`
        

### 1.2 `EconomyShopAPI` 인터페이스 생성

외부 플러그인은 `EconomyShop.getInstance()` 같은 메인 클래스에 직접 접근하기보다, 정제된 API 클래스를 통해야 안전합니다.

- **파일 생성:** `me.antigravity.economyshop.api.EconomyShopAPI` (Interface)
    
- **구현체 생성:** `me.antigravity.economyshop.api.EconomyShopAPIImpl` (Class)
    
- **주요 메서드 정의:**
    
    ```
    public interface EconomyShopAPI {
        // 상점 관리
        ShopManagerAPI getShopManager();
    
        // 경제 관리
        EconomyRegistry getEconomyRegistry();
    
        // GUI 열기
        void openShop(Player player, String shopId);
    }
    ```
    
- **연동:** `EconomyShop` 메인 클래스 `onEnable`에서 `Bukkit.getServicesManager().register(...)`를 통해 API 등록.
    

## 📅 Phase 2: 경제 시스템의 레지스트리화 (Economy Registry)

**목표:** `Vault`나 `PlayerPoints` 외에, 외부 플러그인이 자신만의 화폐(예: RPG 토큰, 클랜 포인트)를 등록할 수 있게 만듭니다.

### 2.1 `EconomyManager` 리팩토링

현재 `EconomyManager`는 특정 플러그인들을 하드코딩으로 체크하고 있을 가능성이 큽니다. 이를 Map 기반의 레지스트리로 변경합니다.

- **수정:** `me.antigravity.economyshop.manager.EconomyManager`
    
- **로직 변경:**
    
    - 기존: `if (type.equals("VAULT")) ...`
        
    - 변경: `Map<String, EconomyProvider> providers`를 두고, `registerProvider(String id, EconomyProvider provider)` 메서드 추가.
        
- **API 노출:** `EconomyRegistry` 인터페이스를 통해 외부에서 `registerProvider` 호출 가능하게 함.
    

## 📅 Phase 3: 상점 생성 및 저장 시스템 (ShopBuilder & Factory)

**목표:** 코드로 상점을 생성하면, 이를 `sections.yml`과 `shops/파일.yml`에 자동으로 직렬화하여 저장하는 시스템을 구축합니다.

### 3.1 `ShopBuilder` 구현 (Fluent API)

외부 플러그인 개발자가 직관적으로 상점을 구성할 수 있도록 빌더 패턴을 도입합니다.

- **파일 생성:** `me.antigravity.economyshop.api.builder.ShopBuilder`
    
- **기능:**
    
    - 상점 ID, 표시 이름, 아이콘, 권한 설정.
        
    - `.build()` 호출 시 `ShopSection` 객체 반환.
        
    - `.register()` 호출 시 `ShopManager`에 등록하고 **파일 저장 로직 트리거**.
        

### 3.2 `ShopManager`의 저장 로직 확장

현재는 `load` 위주입니다. `save` 로직을 강화해야 합니다.

- **기능 추가:** `registerDynamicShop(ShopSection section, boolean persistent)`
    
    - `persistent`가 true면:
        
        1. `sections.yml`에 섹션 정보 기록.
            
        2. `shops/{id}.yml` 파일 생성.
            
        3. 메모리에 로드.
            

## 📅 Phase 4: 커스텀 아이템 지원 (ItemProvider & Serializer)

**목표:** MMOItems, ExecutableItems 등 복잡한 아이템을 상점에 진열하고 저장할 수 있게 합니다.

### 4.1 `ItemSerializer` 추상화

현재 `util/ItemSerializer.java`가 내부 로직만 처리한다면, 이를 확장 가능하게 변경합니다.

- **인터페이스 정의:** `me.antigravity.economyshop.api.item.ItemAdapter`
    
    - `ItemStack serialize(ItemStack item)`: 저장용 변환 (Base64 등)
        
    - `ItemStack deserialize(String data)`: 복구
        
    - `boolean matches(ItemStack shopItem, ItemStack playerItem)`: **핵심**. 단순 Bukkit `isSimilar`가 아닌, 플러그인 고유의 비교 로직(NBT, PDC 체크) 수행.
        

### 4.2 외부 아이템 등록 시스템

- 외부 플러그인은 자신의 `ItemAdapter`를 등록.
    
- 상점 아이템 설정 파일에 `provider: "MMOItems"` 같은 필드 추가.
    
- 상점 거래 시 해당 Provider의 `matches()` 메서드를 사용하여 플레이어 인벤토리 아이템 확인.
    

## 📅 Phase 5: 이벤트 시스템 및 제어권 이양 (Event-Driven)

**목표:** 상점의 모든 생명주기(Lifecycle)에 다른 플러그인이 개입할 수 있도록 Bukkit Event를 호출합니다.

### 5.1 커스텀 이벤트 정의

`me.antigravity.economyshop.api.event` 패키지에 다음 이벤트들을 구현합니다.

1. **`ShopPreTransactionEvent` (Cancellable)**
    
    - 구매/판매 **전** 호출.
        
    - 활용: 특정 조건(퀘스트 미달성 등)에서 거래 취소, 동적 가격 변동(세금 적용).
        
2. **`ShopPostTransactionEvent`**
    
    - 구매/판매 **후** 호출.
        
    - 활용: 로그 기록, 디스코드 알림, 퀘스트 카운트 증가.
        
3. **`ShopOpenEvent` / `ShopCloseEvent`**
    

### 5.2 `ShopListener` 로직 분리

기존 `ShopListener`나 `GUIManager`의 클릭 이벤트 처리 로직 중간중간에 `Bukkit.getPluginManager().callEvent(...)`를 삽입합니다.

## 📅 Phase 6: 구조 정리 및 배포 준비

### 6.1 `jitpack.yml` 및 Maven/Gradle 설정 확인

- 외부 개발자가 `pom.xml`이나 `build.gradle`에 의존성으로 추가할 수 있도록 설정 확인.
    
- `api` 모듈만 별도로 분리하여 배포하는 것도 고려(고급 단계).
    

### 6.2 Javadoc 작성

- `api` 패키지 내의 모든 클래스와 메서드에 Javadoc 작성 필수.
    

## 🚀 예상되는 최종 프로젝트 구조 (Tree)

```
src/main/java/me/antigravity/economyshop
├── api                  <-- [NEW] 외부 공개용 패키지
│   ├── EconomyShopAPI.java
│   ├── builder
│   │   └── ShopBuilder.java
│   ├── economy
│   │   └── EconomyProvider.java
│   ├── event            <-- [NEW] 커스텀 이벤트
│   │   ├── ShopTransactionEvent.java
│   │   └── ...
│   └── item
│       └── ItemAdapter.java
├── command              <-- 기존 커맨드
├── economy              <-- 내부 구현체 (VaultProvider 등)
├── gui                  <-- GUI 홀더 및 로직
├── manager              <-- 내부 매니저 (Singleton)
│   ├── ShopManager.java (API 구현체 연결)
│   └── ...
└── model                <-- 데이터 모델
```